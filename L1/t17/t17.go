package main

import (
	"fmt"
)

// из прошлого задания
func quickSort(a []int) []int {

	// уже отсортирован
	if len(a) < 2 {
		return a
	}

	// правая (считаем опорным элементом) и левая границы
	l := 0
	r := len(a) - 1

	// проходимся по всем элементам, и элементы меньше
	// опорного помещаем влево, и сдвигаем левую границу
	for i := range a {
		if a[i] < a[r] {
			a[i], a[l] = a[l], a[i]
			l++
		}
	}

	// ставим опорный таким образом, чтобы
	// слева были числа меньше опорного, а справа больше
	a[l], a[r] = a[r], a[l]

	// сортируем подмассивы слева и справа от опорного
	quickSort(a[:l])
	quickSort(a[l+1:])

	return a
}

// на вход подается массив и значение, которое нужно найти
// возвращает индекс найденного элемента или -1
func binSearch(a []int, key int) int {

	//границы поиска
	l := 0
	r := len(a) - 1

	// пока границы не сомкнуться
	for l <= r {
		// серединное значение с учетом смещения
		m := l + (r-l)/2
		// если нашли элемент - вернуть индекс
		if a[m] == key {
			return m
		}
		// если ключ меньше серединного значения,
		// то сдвинуть левую границу, иначе правую
		if a[m] < key {
			l = m + 1
		} else {
			r = m - 1
		}
	}

	// если ничего не нашли -1
	return -1
}

func main() {
	data := []int{5, -1, 3, 7, -100, 200, 4, 0, 3, 8}
	// бинарный поиск только для отсортированных значений
	sortedData := quickSort(data)
	// ключи с существующим и несуществующим элементами
	key1 := -1
	key2 := 1000

	fmt.Println("sorted array: ", sortedData)
	fmt.Println("search ", key1, " index = ", binSearch(sortedData, key1))
	fmt.Println("search ", key2, " index = ", binSearch(sortedData, key2))
}
